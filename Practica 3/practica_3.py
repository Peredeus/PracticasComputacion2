# -*- coding: utf-8 -*-
"""Practica 3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sK8fDBaKCd0IxwzlAFQKRhDIvDEBH6vb
"""

#PRACTICA 3 
#AP
#Método de Newthon-Raphson
#FUNCION:f(x)=x**3-cos(x)
import numpy as np
from scipy.optimize import root_scalar 
import matplotlib.pyplot as plt
import time
def f(x):
  return x**3-np.cos(x)


def Df(x):
  return 3*x**2+ np.sin(x)

x0=1
i=1
error=7
while error >1e-6:
  x1=x0-f(x0)/Df(x0)
  error=abs(x1-x0)
  x0=x1
  print("Iteracion",i,"Raiz es:",x0)
  i=i+1

start = time.time()
end = time.time()
timepo = end-start
print("El tiempo que tardo el metodo de Newtown-Rapson es:",end-start)

x=np.linspace(-2,2,100)
plt.plot(x,f(x))
plt.plot(x0,f(x0), 'or')
plt.grid()
plt.show()

#Método de la Secante
def f(x):
  return x**3-np.cos(x)
def Df(x):
  return 3*x**2+ np.sin(x)

def S(f,x0,x1,N=15,emax=1e-6):
  for k in range(N):
    Df=(f(x1)-f(x0))/(x1-x0)
    x=x1-f(x1)/Df
    e=abs((x-x1)/x)
    if e<emax:
      break
    print(k,x,f(x),e)
start = time.time()
end = time.time()
timepo = end-start


S(f,-1,1)
print("La raiz es:",x0)
print("El tiempo que tardo el metodo de la secante es:",end-start)

#Método de Brent-Decker
def f(x):
  return x**3-np.cos(x)

x=np.linspace(start=-2,stop=2,num=100)
plt.plot(x,f(x))
plt.grid()
plt.axhline(y=0,linewidth=2,c='k')
plt.axvline(x=0,linewidth=2,c='k')
plt.show()

sol = root_scalar(f,method='brentq',bracket=[-2,2])
print(f"Metodo de Brent-Decker:\n\
      -Raiz={sol.root}\n\
      -Iteracion={sol.iterations}\n\
      -Evaluaciones={sol.function_calls}\n")
start = time.time()
end = time.time()
timepo = end-start
print("El tiempo que tardo el metodo de Brent-Decker:",end-start)

#Metodo de la biseccion
def f(x):
  return x**3-np.cos(x)
x=np.linspace(-2,2)

print("x=\n",x)
print("f(x)=\n",f(x))
plt.plot(x,f(x))
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True)
plt.show()

a=-10
b=10
c=(a+b)/2
error=15
i=0


  
while error>1e-8:
  
  c=(a+b)/2
  fa=f(a)
  fc=f(c)
  if fc==0:
    raiz=c
    break
  
  elif fa*fc<0:
    b=c
  else:
    a=c
  raiz=c
  i+=1
  error=abs(fc)
start = time.time()
end = time.time()
timepo = end-start
print("La raiz de esta funcion es:",raiz)
print("Las iteraciones que realizo fueron:",i)
print("El tiempo que tardo el metodo de la bisección es:",end-start)

#Metodo busqueda exhaustiva
start = time.time()
ini=-2
fin=2
c=0
xi=ini
pas=0.1

while ini <=fin:
  dx=c*pas
  xi=ini-dx
  if f(xi)<0.0001:
    break
  else:
    c=c+1

end = time.time()
elapsedNaive = end-start
print("El tiempo que tardo el metodo de busqueda exhaustiva es: ", (end-start))
print("Las raices de la funcion son:",xi)